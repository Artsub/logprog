# Отчет по лабораторной работе №1
## Работа со списками 
## по курсу "Логическое программирование"

### студент: Субботин А.О.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Левинская М.А.|              |               |


## Введение

Списки в языке Prolog представляют собой основной способ работы с последовательностями элементов и используются для хранения и обработки данных. Они представляют собой упорядоченные коллекции, которые могут содержать любой тип данных, включая числа, атомы, другие списки и даже переменные.

## Задание 1.1: Предикат обработки списка

`delete_(X1,X2)` - удаление первых трёх элементов списка

Примеры использования:
```prolog
?- delete_([1,2,3],X)
X = []
?- delete_([1,2,3,4,5,6,100], X).
X = [4, 5, 6, 100]

```

Реализация:

```prolog
% с использованием стандартных предикатов 
delete_(X, X_3):- length(X, R), R > 3, append([_], X_1, X), append([_], X_2, X_1), append([_], X_3, X_2),!.
delete_(X, []):- length(X, R), R =< 3. 

% без использования стандартных предикатов
remove_first([_|X], X).
delete_(X, X_3):- length(X, R), R > 3, remove_first(X, X_1),remove_first(X_1, X_2), remove_first(X_2, X_3).
delete_(X, []):- length(X, R), R =< 3.
```

Проверяем с помощью предиката length, вычисляющего длину, будет ли она принимать значение большее 3, если больше, удаляем три раза первый элемент(либо с помощью функции `remove_first`, либо с помощью функции `append`), если меньше, возвращаем пустой список.

## Задание 1.2: Предикат обработки числового списка

Вычисление скалярного произведения двух векторов-списков (с учетом возможного несовпадения размерностей).
```prolog
scalarproduct(V1, V2, P)
```

Примеры использования:
```prolog
?- scalarproduct([3, 4],[5, 6],X).
X = 39.

?- scalarproduct([3, 4, 4],[5, 6],X).
false.

?- scalarproduct([4, 5, 7],[5, 6, 1],X).
X = 57.
```

Реализация:
Задается рекурсивно. Скалярное произведение двух пустых списков равно нулю. Если в списке > 1 эл-та, то отделяем хвосты `XT`  и `YT` И находим их произведение, пока не дойдем до голов `X` и `Y` и прибавив их произведение к суммме произведений `P` получим скалярное произведение `S`.
```prolog
scalarproduct([],[],0).
scalarproduct([X|XT],[Y|YT],S) :-
    !,
    scalarproduct(XT, YT, P), 
    S is (P + X * Y).
```

В реализации с использованием стандартных предикатов используются два вспомогатльных предиката - предикат нахождения суммы всех элементов `sum` и предикат `length`, определяющий длину списка. Сумма элементов делится на длину списка. 
В реализации без использования стандартных предикатов длина и сумма элементов считаются в процессе выполнения программы - во время каждой процедуры отделения головы от хвоста к одной из переменных (S) прибавляется значение головы, а в другой (C) - единица.

## Выводы

Использование языка Prolog для решения задач со списками отличается лаконичностью и выразительностью, благодаря мощным средствам работы с рекурсией, сопоставлением с образцом и встроенными предикатами. Трудности вызывает сложный по сравнению с императивными языками программирования синтаксис.



